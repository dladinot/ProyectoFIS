\chapterimage{754559_image12520430_0.jpg}
\chapter{Conlusiones}
Sería conveniente dividir las conclusiones en partes, lo creemos conveniente, pues así no solo nos limitaremos a el modelado si no también podremos abarcar más ámbitos. 

Lo primero es concluir sobre la idea como tal del proyecto y en sí de nuestra aplicación, la finalidad de nuestra aplicación siempre fue la de asegurar una gestión rápida concisa y ordenada a las tareas relacionadas con las monitorias de la universidad, para ser específicos de la Universidad Francisco José de Caldas, motivo por el cual optamos por la virtualización de este proceso, y con ello todos las mejoras que conlleva, en este punto dividimos nuestra aplicación en varios componentes, para así poder realizar una abstracción optima que nos permitiera abarcar todo el proyecto, y poder desarrollarlo de una manera más ordenada. 

La finalidad de dividir nuestro proyecto en componentes, fue conocer y abarcar todas las capacidades y en si las limitaciones que tendría nuestro proyecto, de esta manera al realizar ya la implementación de nuestros modelos, no habría sorpresas ni imprevistos. 

Cuando hablamos de capacidades y limitaciones, empezó un análisis más que extenso en toda nuestra aplicación, y de hecho consideramos que la explicación conceptual de estas dos palabras en relación a nuestra aplicación englobaba un gran porcentaje del trabajo. Y es que cuando hablamos de las capacidades de nuestro proyecto en si proyectábamos las funciones que requeríamos fueran cumplidas, y es aquí donde entra todo el modelado de nuestro proyecto, cada diagrama usado, desde nuestro típico diagrama de clases, que describía tanto los objetos de todo el proyecto como cada uno de sus componentes y de hecho los diferenciaba entre sí, este tipo de diagramas ya eran un diseño especifico de lo que realizaríamos, siguiendo con diagramas un tanto más abstractos y de funcionalidad como lo fue el diagrama de actividades, claro después se tenían que representar las relaciones entre objetos y los cambios que estos mensajes provocaba, aquí entraron los diagramas de estado, secuencia y comunicación, de esta manera, y con todas esta abstracciones se aclaró y facilito la división de componentes y la implementación era ya solo un breve paso. 

Continuando, nos dimos cuenta que nuestro proyecto se enfrentaría a limitaciones y casi haciendo una predicción nos aferramos a los patrones de diseño, para evitar cualquier inconveniente, de este modo evitando el nacimiento de errores que parecerían inevitables. 

Llegando al punto culmen de modelamiento que se representa en nuestro capítulo de despliegue, desarrollamos el proyecto de tal manera que nos apoyamos en diagramas mucho más amplios como los diagramas de sistemas, componentes y nodos. De este modo y con ciertas métricas fuimos capaces de ir avanzando en prototipos según nuestra metodología. 
Aquí ya entramos en una análisis y conclusión ya distinto al modelamiento, y es el de estas mismas metodologías manejadas, en nuestro caso decidimos un desarrollo de tipo scrum, esto debido al tiempo estimado, y esto nos permitió un avance rápido, pero también hemos de mencionar que no todos los avances eran de implementación y prototipos, pues la parte de desarrollo y diagramas consumió la primera parte de nuestro cronograma.  Por ello durante el transcurso del proyecto, aunque seguimos ciertos parámetros, terminamos con una combinación que se ajustara a nuestras posibilidades. 

Ya para finalizar, el hecho de haber abordado el proyecto de esta manera nos permitió hacer una aplicación con un ciclo de vida más amplio y con unos parámetros necesarios para poderla hacer apta para prestar un servicio y una función .   

